'''
Nash Equilibria on (Un-)Stable Networks

2020
Anton Badev
anton.badev@gmail.com

PLOTS COUNTERFACTUAL EXPERIMENT PRICE CHANGE (AS A RESULT OF EXCISE TAX)
    -A- Table comparing policy effect under different scenarios
    -B- Plot compare distribution of overall smoking under selected scenarios 
    -C- Tests effect of price changes on the distribution of overall smoking 

Input files:
    ctrfPrice.data (in scratchdir)
    
Output files:
    table_ctrfPrice.tex
    table_ctrfPrice_tests.tex
    fig_ctrfPrice_compareDistSmoking.pdf

Note output in texdir
    ctrfPrice.data generated by ctrfPrice.py
'''


import os,sys,csv,multiprocessing,functools
import time
import numpy as np
import pandas as pd
import scipy.io as sio
import pickle
from sklearn.neighbors import KernelDensity
from scipy import stats
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec


from libsetups import state2pickle
from libsetups import setupdirs
from libposteriors import posteriorStats
from libnets import netStats
from libnets import stateStats
from libnets import homophily
from libnets import mixingMat



def weighted_average_bygroup(dfin,data_col,weight_col,by_col):
    df=dfin.copy()
    df['_data_times_weight'] = df[data_col]*df[weight_col]#/float((df[weight_col].sum())
    df['_weight_where_notnull'] = df[weight_col]*pd.notnull(df[data_col])
    g = df.groupby(by_col)
    result = g['_data_times_weight'].sum() / g['_weight_where_notnull'].sum()
    del df['_data_times_weight'], df['_weight_where_notnull']
    return result

def weighted_average(df,data_col,weight_col):
    result = np.average(df[data_col].to_numpy(float),axis=None,weights=df[weight_col].to_numpy(float))
    #result = df[data_col]*df[weight_col].astype(float)).sum()/float(df[weight_col].sum())
    return result

def weightedmean_meanCtrfPrice(df,varname):
    result = np.average(df[varname].to_numpy(float),axis=0,weights=df['netsize'].to_numpy(float))
    return result


def main():

    [systime0,pyfilename,pyfiledir,homedir,currentdir,scratchdir,hostname,sysname] = setupdirs()
    ctrfIncomeDir = scratchdir
    ctrfIncomeData= '/ctrfIncome_test_10.data' #3 SCENARIOS
    ctrfIncomeData= '/ctrfIncome.data' #3 SCENARIOS
    with open(ctrfIncomeDir+ctrfIncomeData, 'rb') as filehandle:
        [ctrfIncomeData,numsim,gridDeltaIncome,num_nets, size_nets, attr, data_a, data_g]=pickle.load(filehandle)
    #ctrfPriceSim
    #   [scid]
    #       [simdata,simdataFixedNet,simdataPEoff,simdataNoPE]
    #           [sim_a, sim_g, jprice, jscid]

    texdir   = currentdir + '/../TeX/'
    texfile  = 'table_ctrfIncome.tex'
    texfile2 = 'table_ctrfIncome_tests.tex'


    ctrfPriceData=ctrfIncomeData
    gridDeltaPrice=gridDeltaIncome




    ctrfPrice  =pd.concat(ctrfPriceData,ignore_index=True) #all scids in one df
    ctrfPrice0 =ctrfPrice[(ctrfPrice.sim==0)].copy() #sim=0 is data, for all scid, for all ctrf scenarios
    ctrfPrice  =ctrfPrice[~(ctrfPrice.sim==0)].copy()
    ctrfPrice.sim = ctrfPrice.sim - 1
    
    
    #weighted & unweighted mean
    meanCtrf  = ctrfPrice.groupby(['dprice']).mean().reset_index()
    ctrfPrice['mean_weights']= float(num_nets)*ctrfPrice.netsize/float(sum(size_nets))
    WctrfPrice=ctrfPrice.copy()
    for j,jvar in enumerate(list(WctrfPrice.columns)[3:-1]):
        print(jvar)
        WctrfPrice[jvar]=WctrfPrice[jvar]*WctrfPrice['mean_weights']
    WmeanCtrf = WctrfPrice.groupby(['dprice']).mean().reset_index()#).copy()
    ctrfPolicy = WmeanCtrf - WmeanCtrf.iloc[0].values.squeeze()

    table_ctrfPrice=''
    for ii in range(len(gridDeltaPrice)-1):
        dp_ii=int(100-100*gridDeltaPrice[ii+1])
        texline= f'{dp_ii:4.0f}'
        for j,jscenario in enumerate(['prev-Model', 'prev-FixedNet','prev-noNetData']):
            deltaPrev = -100*ctrfPolicy.loc[ii+1,jscenario]
            texline = texline + f' & {deltaPrev:4.1f}'        
        table_ctrfPrice = table_ctrfPrice + texline + r' \\' + ' \n'
            
    texsignature=f'% tex created by {pyfilename}.py \n'
    texheader = r'''
    \begin{table}[!t]
    \caption{Changes in the price of tobacco}
    \label{table:ctrf-price}
    \begin{center}
    \begin{tabular}{cccccc}
    Price increase & Model  &  Exog net & No net data\\ \hline \hline
    '''
    
    texfooter = r'''
    \hline
    \end{tabular}
    \end{center}
    \fignotetitle{Note:} The first column shows proposed increases in tobacco prices in cents. 
    The average price of a pack of cigarettes is \$1.67 so that 20 cents is approximately 10\%. 
    The second through fourth columns show the predicted increase in the overall smoking (baseline 41\%) in ppt 
    from the full model, from the model when the friendship network is fixed, and 
    from the model when no social network data is available. 
    In this last scenario the local peer effect term is absent so that $\phi$ is forced to equal zero in the estimation. 
    \end{table}
    '''
    
    texcontent = texsignature + texheader + table_ctrfPrice + texfooter
    with open(texdir+texfile,'w') as f:
        f.write(texcontent)

    
    # -B- Compare the distribution of overall smoking under different price scenarios
    graphdir=texdir
    graphfile='fig_ctrfPrice_compareDistSmoking.pdf'
    models_labels      =['Endog net dP=40','Fixed net dP=40',
                         'Endog net dP=80','Fixed net dP=80',
                         'Endog net dP=120','Fixed net dP=120']
    models_labels      =['dP=40','Fixed net dP=40',
                         'dP=80','Fixed net dP=80',
                         'dP=120','Fixed net dP=120',
                         'dP=160','Fixed net dP=160']
     
    prev_range = np.linspace(0, 30, 100)[:, np.newaxis]#adds axis to 1d to make it 2d array
    
    simCtrfPrice=(ctrfPrice.loc[:,:'prev-noNetData']).copy()
    simCtrfPrice['weights']=simCtrfPrice['netsize']/allnetssize 
    for j,stat in enumerate(simCtrfPrice.columns):
        if j>3 and j<7:
            simCtrfPrice[stat]=simCtrfPrice[stat]*simCtrfPrice['weights']
    drawsCtrfPrice=simCtrfPrice.groupby(['sim', 'dprice']).sum().reset_index()
    drawsCtrfPrice_wide=-100*drawsCtrfPrice.pivot(index='sim', columns='dprice', 
                                                  values=['prev-Model', 'prev-FixedNet', 'prev-noNetData'])


    fig, axs = plt.subplots()
    linestyles1 = ['g-', 'b-', 'y-', 'r-']
    linestyles2 = ['g:', 'b:', 'y:', 'r:']
    linewidths = [2,2,2,2,2]

    for j,jj in enumerate([3,5,7]):
        print(j,jj)
        x =drawsCtrfPrice_wide.iloc[1:,jj][:, np.newaxis] - drawsCtrfPrice_wide.iloc[1:,1][:, np.newaxis]#.to_numpy()
        xx=drawsCtrfPrice_wide.iloc[1:,jj+10][:, np.newaxis] - drawsCtrfPrice_wide.iloc[1:,1+10][:, np.newaxis]#.to_numpy()
        
        kde = KernelDensity(kernel='gaussian', bandwidth=1.5).fit(x)
        log_dens = kde.score_samples(prev_range)
        axs.plot(prev_range, np.exp(log_dens), linestyles1[j],linewidth=linewidths[j], label="{0}".format(models_labels[jj-3]))
        kde = KernelDensity(kernel='gaussian', bandwidth=1.5).fit(xx)
        log_dens = kde.score_samples(prev_range)
        #axs.plot(prev_range, np.exp(log_dens), linestyles[jj-2],linewidth=linewidths[j], label="{0}".format(models_labels[jj-2]))
        axs.plot(prev_range, np.exp(log_dens), linestyles2[j],linewidth=linewidths[j])

    
    axs.legend(loc='upper right')
    #ax.plot(X[:, 0], -0.005 - 0.01 * np.random.random(X.shape[0]), '+k')
    axs.set_xlim(np.min(prev_range), np.max(prev_range))
    #axs.tick_params(axis='y', bottom='off', top='off', labelbottom='off', right='off', left='off', labelleft='off')
    #axs.axes.get_yaxis().set_visible(False)
    xmarks=[i for i in np.linspace(np.min(prev_range),np.max(prev_range),5)]
    plt.xticks(xmarks,rotation=45)
    axs.spines['right'].set_visible(False)
    axs.spines['top'].set_visible(False)
    axs.spines['left'].set_visible(False)
    axs.set_yticklabels([])
    axs.set_yticks([])
    
    plt.savefig(graphdir+graphfile, dpi=300)
    
    
    # -C- Compare policy effects for different levels of price change
    models_labels =['dP=20','dP=40','dP=60','dP=80','dP=100','dP=120']
    models_labels =['20','40','60','80','100','120']
    nmodels=len(models_labels)
    p1=np.zeros([nmodels,nmodels])
    p2=np.zeros([nmodels,nmodels])
    for j in range(nmodels):
        for jj in range(nmodels):
            rvs1=(drawsCtrfPrice_wide.iloc[1:,j+2] - drawsCtrfPrice_wide.iloc[1:,1]).to_numpy()
            rvs2=(drawsCtrfPrice_wide.iloc[1:,jj+2]- drawsCtrfPrice_wide.iloc[1:,1]).to_numpy()
            
        
            #rvs1=posteriorsPrice.iloc[:,j].to_numpy()
            #rvs2=posteriorsPrice.iloc[:,jj].to_numpy()
            [t, p1[j,jj]]=stats.ttest_ind(rvs1,rvs2, equal_var = False)
    
            #rvs1=posteriorsPrice.iloc[:,j].to_numpy()
            #rvs2=posteriorsPrice.iloc[:,jj].to_numpy()
            [t, p2[j,jj]]=stats.ks_2samp(rvs1,rvs2)


    texsignature=f'% tex created by {pyfilename}.py \n'
    texheader = r'''
    \begin{table}[!h]
    \caption{Pairwise tests of the policy effects for different levels of price change}
    \label{table:ctrf-posteriorPrice-tests}
    \begin{center}
    \begin{tabular}{lccccccc}
    Policy & \multirow{2}{*}{20} & \multirow{2}{*}{40}&\multirow{2}{*}{60}&\multirow{2}{*}{80}&\multirow{2}{*}{100}&\multirow{2}{*}{120} \\
    level (dP)&  \\ \hline \hline
    '''
    #grid_policy=range(0,60,10)
    table_ctrf=''
    for r,model in enumerate(models_labels):
        texline= f'{model:12}'
        for c in range(r+1):
            texline = texline + f' & {p1[r,c]:4.2f} ({p2[r,c]:4.2f})'        
        table_ctrf = table_ctrf + texline + r' \\' + ' \n'
        
    texfooter = r'''
    \hline
    \end{tabular}
    \end{center}
    \fignotetitle{Note:} \fignotetext{
    Each cell compares the policy effects for a pair of price changes.
    The two p-values are from testing a hypothesis of equal means and from testing a hypothesis of equal distributions
    (two-sample Kolmogorov-Smirnov test).}
    \end{table}
    '''
    
    texcontent = texsignature + texheader + table_ctrf + texfooter
    with open(texdir+texfile2,'w') as f:
         f.write(texcontent)




if __name__ == '__main__':
    main()
